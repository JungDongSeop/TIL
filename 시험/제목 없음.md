#### 순열

TSP (Traveling Salesman Problem) 등에 적용 가능

- 최소 변경을 통한 방법 (Minimum-exchange requirement)

  - 각 순열들은 이전의 상태에서 요소 2개만을 바꿔 생성 가능

  - ```python
    def perm(n, k):
        if n == k:
            print arr
        else:
            for i in range(k, N):
                arr[i], arr[j] = arr[j], arr[i]
                perm(n, k+1)
                arr[i], arr[j] = arr[j], arr[i]
    ```

- 내 방식

  - ```python
    def permutation(idx):
        if idx == N:
            print(arr)
            return
        for i in range(N):
            if i not in arr:
                arr.append(i)
                permutation(idx + 1)
                arr.pop()
    ```

  - 

#### 부분집합

배낭 문제(knapsack) 등에 적용 가능

- 바이너리 카운팅을 통한 예제

  - ```python
    arr = [3, 6, 7, 1, 5, 4]
    n = len(arr)
    
    for i in range(1 << n):
        for j in range(n):
            if i & (1 << j):
                print(arr[j], end=' ')
        print()
    ```

- 내 방법

  - ```python
    ans = []
    def recur(idx):
        if idx == n:
            print(ans)
            return
    
        recur(idx+1)
        ans.append(arr[idx])
        recur(idx+1)
        ans.pop()
    ```

- 반복문

  - ```python
    arr = [1, 2, 3]
    subsets = [[]]
    
    for num in arr:
      size = len(subsets)
      for y in range(size):
        subsets.append(subsets[y]+[num])
    print(subsets)
    ```

#### 조합

nCr

- 재귀호출

  - ```python
    an = [1, 3, 5 ,6]
    tr = [0] * r		# 정답 저장할 리스트
    def combi(n, r):
        if r == 0:
            print(tr)
            return 
        if n < r:
            return
        tr[r-1] = an[n-1]
        combi(n-1, r-1)
        combi(n-1, r)
    ```

  - ```python
    A = [1, 3, 5, 6]
    combi = [0] * 2
    def nCr(n, r, s):
        if r == 0:
            print(*comb)
        	return
        for i in range(s, n-r+1):
            comb[r-1] = A[i]
            nCr(n, r-1, i+1)
    nCr(4, 2, 0)
    ```

- 스택

  - ```python
    def combination(arr, idx, n):
        if len(stack) == n:
            print(stack)
            return
    
        for i in range((stack[-1] if stack else -1) + 1, idx + (len(arr) - n) + 1):
            if arr[i] not in stack:
                stack.append(i)
                combination(arr, idx + 1, n)
                stack.pop()
    
    stack = []
    combination([0, 1, 2, 3, 4, 5, 6], 0, 4)

그냥 조합

- 재귀호출

  - ```python
    arr = [1, 2, 3]
    comb = []
    def combi(idx):
        if idx == n:
            print(comb)
            return
        combi(idx+1)
        comb.append(arr[idx])
        combi(idx+1)
        comb.pop()
    ```



## MST

- 신장 트리

  n개의 정점으로 이루어진 무방향 그래프에서 n개의 정점과 n-1개의 간선으로 이루어진 트리

- 최소 신장 트리

  무방향 가중치 그래프에서 신장 트리를 구성하는 간선들의 가중치 합이 최소인 신장 트리 

prim 알고리즘

- 다익스트라와 비슷

1. 임의 정점 하나 선택

2. 선택한 정점과 인접하는 정점들 중 최소 비용 간선이 선택하는 정점 선택

   분리 집합 활용

3. 반복

   ```python
   def prim():
   	visited[start] = 1
       candidate = G[start]	# 시작점 인접 간선
       heapify(candidate)	# 최소 힙으로 만들기
       mst = []
       
       while candidate:
           weight, u, v = heappop(candidate)
           
           if not visited[v]:
               visited[v] = 1
               mst.append((u, v))	# u <-> v 간선 추가
               
               for edge in G[v]:
                   if not visited[edge[2]]:
                       heappush(candidate, edge)
   ```

kurskal 알고리즘

1. 간선을 가중치에 따라 정렬

2. 그리드 알고리즘으로, 해당 간선의 양끝 노드가 서로 분리되어 있으면 선택 (분리 집합 사용)

3. 간선 개수가 V-1일 때까지 반복

   ```python
   def mst():
       cnt = 0 # 간선의 개수
       result = 0 # 전체 가중치의 합
       idx = 0 # 조사 대상
   
       while cnt < V: # 사이클 없는 트리의 간선의 개수는 V-1
           p1 = findSet(arr[idx][0])
           p2 = findSet(arr[idx][1])
           # 사이클이 형성되지 않을때
           if p1 != p2:
               # arr 은 가중치 기준으로 오름차순 정렬 하였으므로 일단 삽입
               result += arr[idx][2] # idx 번째 정보의 n1 과 n2 사이의 간선잇기
               cnt += 1 # 간선 개수 하나 늘림
               parent[p2] = p1	# 집합 합치기
           idx += 1
   
       return result
   ```



## 다익스트라

```python
def dijkstra(start, goal):
    heap = [(0, start)]
    visited = [INF] * (V+1)

    visited[start] = 0
    while heap:
        dist, now = heappop(heap)

        if visited[now] < dist:
            continue

        for next, long in adjList[now]:
            cost = dist + long
            if visited[next] > cost:
                heappush(heap, (cost, next))
                visited[next] = cost
    return visited[goal]

```

