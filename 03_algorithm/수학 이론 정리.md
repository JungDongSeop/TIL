### 페르마의 소정리

1. $p$가 소수이면, 모든 정수 $a$에 대해 $a^p \equiv a$ (mod $p$) 이다.

2. $p$가 소수이고 $a$가 $p$의 배수가 아니면, $a^{p-1} \equiv 1$ (mod $p$) 이다.


이를 활용한 모듈러 곱셈 역원 구하기

- $a^{p-2} = a^{-1} \mod p$



### 뤼카의 정리

임의의 음이 아닌 정수 $m$과 $n$, 소수 $p$에 대하여 
$$
_mC_n \equiv \prod ^k _{i=0} {_{m_i}}C_{n_i}  \mod p\\
(m = m_kp_k + ... + m_1p + m_0\\
n = n_kp_k + ... + n_1p + n_0)
$$

### 중국인의 나머지 정리

### 확장 유클리드 호제법

$ax + by = 1$인 $x, y$를 구하는 방법

코드

```python
# xa, ya, xb, yb는 a = k*xa + c*ya, b = k*xb + c*yb인 숫자들
def euclidean(a, b, xa, ya, xb, yb):
    # print(a, b, xa, ya, xb, yb)
    if b == 1:
        return yb
    if b == 0:
        return 'IMPOSSIBLE'

    a, b, xa, ya, xb, yb = b, a % b, xb, yb, xa - xb*(a//b), ya - yb*(a//b)

    return euclidean(a, b, xa, ya, xb, yb)
```

### 밀러 라빈 소수판정법

확률적 소수 판별 알고리즘

소수임을 O(n^(1/2)) 보다 빠르게 판정하기

but 정확히 판단하는 것은 아닌 듯하다. 합성수지만 소수라고 판단하는 경우가 가끔 있는 듯?

일정 수 이하 (300조 정도?)는 확실히 소수를 판별할 방법이 있는 듯하다. (위키백과 참조)

```python
# a^n 을 분할정복으로 빠르게 계산
def pow_merge(a, n, p):
    if n == 1:
        return a % p
    tmp = (pow_merge(a, n//2, p)) % p
    if not n % 2:
        return (tmp * tmp) % p
    if n % 2:
        return (((tmp * tmp) % p) * a) % p

def miller_rabin(p):
    s, d = 0, p-1
    while not d % 2:
        s += 1
        d = d//2
    flag = True        # flag가 Ture면 소수임을 의미

    for a in [2, 7, 61]:
        if a % p == 0:
            continue
        if not flag:
            break
        tmp = pow_merge(a, d, p)    # a^d == 1 (mod p)

        if tmp == 1:				# 밀러 라빈의 첫번째 조건
            continue
        for r in range(0, s):       # 밀러 라빈의 두번째 조건, 이 때 0 <= r <= s-1
            if tmp == p - 1 and s:
                break
            tmp = (tmp * tmp) % p
        else:
            flag = False
    return flag
```



### 폴라드 로 알고리즘

소인수분해

### 고속 푸리에 변환



## 응용

뤼카의 정리, 중국인의 나머지 정리, 확장 유클리드 호제법을 사용하여 `nCr (mod k)`를 보다 빠르게 구할 수 있다.
