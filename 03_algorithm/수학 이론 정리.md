### 페르마의 소정리

1. $p$가 소수이면, 모든 정수 $a$에 대해 $a^p \equiv a$ (mod $p$) 이다.

2. $p$가 소수이고 $a$가 $p$의 배수가 아니면, $a^{p-1} \equiv 1$ (mod $p$) 이다.


이를 활용한 모듈러 곱셈 역원 구하기

- $a^{p-2} = a^{-1} \mod p$



### 뤼카의 정리

임의의 음이 아닌 정수 $m$과 $n$, 소수 $p$에 대하여 
$$
_mC_n \equiv \prod ^k _{i=0} {_{m_i}}C_{n_i}  \mod p\\
(m = m_kp_k + ... + m_1p + m_0\\
n = n_kp_k + ... + n_1p + n_0)
$$

### 중국인의 나머지 정리

15718_돌아온 떡파이어 (뤼카 정리 + 중국인의 나머지 정리)

```python
# 그냥 조합으로 풀면 시간초과가 난다.
# 1. 100007 == 97 * 1031 임을 이용해서, 뤼카의 정리 사용
# 2. nCr을 97로 나눈 나머지와 1031로 나눈 나머지를 이용해, 중국인의 나머지 정리 사용

# nCr 을 구하는 함수
def combi(n, r):
    if n < r:
        return 0
    top = 1
    bot = 1
    for i in range(min(r, n-r)):
        top *= n-i
        bot *= 1+i
    return top // bot

# 뤼카의 정리
def Lucas_thm(n, r, p):
    n_arr = []
    r_arr = []

    while n or r:
        n_arr.append(n % p)
        r_arr.append(r % p)
        n = n//p
        r = r//p

    result = 1
    for i in range(len(n_arr)):
        result *= combi(n_arr[i], r_arr[i]) % p

    return result % p

# 확장 유클리드 호제법을 사용해서 a*p1 + b*p2 == 1 (mod p1*p2)인 a, b 구하기
# 이 문제에 한해선 p1, p2가 정해져 있으니, a==35, b==659를 바로 사용
def find_eucledean(a, b, xa, ya, xb, yb):
    if b == 1 or not a%b:
        return xb
    a, b, xa, ya, xb, yb = b, a % b, xb, yb, xa - xb * (a // b), ya - yb * (a // b)
    return find_eucledean(a, b, xa, ya, xb, yb)

# x==m1 (mod p1), x==m2(mod p2) 인 x 구하기
def chniese_remainder_thm(m1, m2, p1, p2):
    # # s1, s2 구하기
    # s1 = find_eucledean(p2, p1, 1, 0, 0, 1)
    # if s1 < 0:
    #     s1 = p1 + s1
    # s2 = find_eucledean(p1, p2, 1, 0, 0, 1)
    # if s2 < 0:
    #     s2 = p2 + s2
    s1, s2 = 35, 659
    result = (s1*p2*m1 + s2*p1*m2)
    return result % 100007

T = int(input())
for tc in range(T):
    N, M = map(int, input().split())
    n, r = N-1, M-2

    if N == 0:
        print(1 if M == 1 else 0)
        continue
    if N == 1:
        print(1 if M == 2 else 0)
        continue
    if M == 1:
        print(0)
        continue

    res_97 = Lucas_thm(n, r, 97)
    res_1031 = Lucas_thm(n, r, 1031)
    answer = chniese_remainder_thm(res_97, res_1031, 97, 1031) % (97*1031)

    print(answer)
```



### 오일러 피 함수

![{\displaystyle \phi (n)=n\prod _{p\mid n}\left(1-{\frac {1}{p}}\right)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/f435f9cc2f15d34d49245f30d4d85a8cc678fa9d)

이 때 $\pi (n)$ 은 n 과 서로소인 1부터 n까지의 정수의 개수

### 확장 유클리드 호제법

$ax + by = 1$인 $x, y$를 구하는 방법

코드

```python
# xa, ya, xb, yb는 a = k*xa + c*ya, b = k*xb + c*yb인 숫자들
def euclidean(a, b, xa, ya, xb, yb):
    # print(a, b, xa, ya, xb, yb)
    if b == 1:
        return yb
    if b == 0:
        return 'IMPOSSIBLE'

    a, b, xa, ya, xb, yb = b, a % b, xb, yb, xa - xb*(a//b), ya - yb*(a//b)

    return euclidean(a, b, xa, ya, xb, yb)
```

### 밀러 라빈 소수판정법

확률적 소수 판별 알고리즘

소수임을 O(n^(1/2)) 보다 빠르게 판정하기

but 정확히 판단하는 것은 아닌 듯하다. 합성수지만 소수라고 판단하는 경우가 가끔 있는 듯?

일정 수 이하 (300조 정도?)는 확실히 소수를 판별할 방법이 있는 듯하다. (위키백과 참조)

```python
# a^n 을 분할정복으로 빠르게 계산
def pow_merge(a, n, p):
    if n == 1:
        return a % p
    tmp = (pow_merge(a, n//2, p)) % p
    if not n % 2:
        return (tmp * tmp) % p
    if n % 2:
        return (((tmp * tmp) % p) * a) % p

def miller_rabin(p):
    s, d = 0, p-1
    while not d % 2:
        s += 1
        d = d//2
    flag = True        # flag가 Ture면 소수임을 의미

    for a in [2, 7, 61]:
        if a % p == 0:
            continue
        if not flag:
            break
        tmp = pow_merge(a, d, p)    # a^d == 1 (mod p)

        if tmp == 1:				# 밀러 라빈의 첫번째 조건
            continue
        for r in range(0, s):       # 밀러 라빈의 두번째 조건, 이 때 0 <= r <= s-1
            if tmp == p - 1 and s:
                break
            tmp = (tmp * tmp) % p
        else:
            flag = False
    return flag
```



### 폴라드 로 알고리즘

소인수분해





#### 백준 https://www.acmicpc.net/source/49669730 에서 얻은? 훔친? 코드

```python
def modPow(base, pow, mod):
    result = 1
    while pow > 0:
        if pow % 2 == 1:
            result = result * base % mod
        base = base * base % mod
        pow //= 2
    return result

def millerRabin(n, p):
    if p % n == 0:
        return True
    k = n - 1
    while True:
        tmp = modPow(p, k, n)
        if tmp == n - 1:
            return True
        if k % 2 == 1:
            return (tmp == 1 or tmp == n - 1)
        k //= 2

def isPrime(n):
    prime = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]
    if n == 2:
        return True
    elif n % 2 == 0:
        return False
    else:
        for i in prime:
            if n == i:
                return True
            if not millerRabin(n, i):
                return False
    return True

def gcd(a, b):
    if b > a:
        a, b = b, a
    while b != 0:
        r = a % b
        a = b
        b = r
    return a

def f(x, n):
    return ((x * x) + 1) % n

def pollardRho(n, x):
    tmp = x
    if isPrime(n):
        return n
    else:
        for i in [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]:
            if n % i == 0:
                return i
        y, g = x, 1
        while g == 1:
            x = f(x, n)
            y = f(f(y, n), n)
            g = gcd(abs(x - y), n)
        if g == n:
            return pollardRho(n, tmp + 1)
        elif isPrime(g):
            return g
        else:
            return pollardRho(g, 2)
```







### 고속 푸리에 변환



## 응용

뤼카의 정리, 중국인의 나머지 정리, 확장 유클리드 호제법을 사용하여 `nCr (mod k)`를 보다 빠르게 구할 수 있다.
