# Algorithm

이왕이면 지킬 것

- 주석, 변수명 이해하기 쉽게 할 것

- 익숙해질 때까지 내장함수 막 쓰지 말 것

- 1일 1알고리즘

- f스트링 안에 계산식 넣지 않기 (이왕이면 변수명만 넣기)

배운 점?

- 중복을 고려하지 않아야 할 경우, 집합 생각해보기

## 정렬

버블 정렬

- 인접한 2개의 값을 비교, 교체

- 복잡도 O(n^2)

카운트 정렬

- 주어진 행렬의 i번째 값 a에 대해, 새로운 count_list 만든 뒤 count_list[a] += 1

- 복잡도 O(n+k) `k는 값 a 중 최댓값`

선택 정렬

- 주어진 자료 중 가장 작은 값의 원소부터 차례대로 선택하여 위치 교환(맨 앞으로)

- 교환 횟수가 버블, 삽입 정렬보다 작다

- 복잡도 O(n^2)

## 브루트 포스 (완전탐색검사)

모든 경우의 수를 검사

#### 비트 연산자

`&` : 비트 단위로 AND 연산

`|` : 비트 단위로 OR 연산

`1<<n` : 2^n, 즉1짜리 bit를 오른쪽으로 n칸 이동

`i&(1<<j)` : i의 j번째 비트가 1인지 아닌지를 검사

이를 이용해서 부분집합을 생성하는 코드 만들 수 있음

#### 검색

저장된 자료 중 원하는 항목을 찾는 작업

탐색 키 : 자료를 구별하여 인식할 수 있는 키

- 순차 검색 (전부 순회하여 조사)
  
  - 일렬로 되어 있는 자료 검색, 간단, 비효율적
  
  - 복잡도 O(n) (정렬되어 있든 아니든)

- 이진 검색 (절반씩 나눠서 조사)
  
  - 자료의 가운데 키 값과 비교하여 다음 검색의 위치 결정, 정렬된 형태만 가능
  
  - 검색 범위의 시작 s, 끝 e를 이용하여 반복문 수행 (`while s <= e` 형태 추천, 이후 `s=m+1`, `e=m-1`)

- 해쉬 

#### 전치행렬

`arr = list(zip(*arr))`

#### 배열의 상하좌우 구하기

```python
di = [0,0,-1,1]
dj = [-1,1,0,0]
```

해서 각 i, j에 i+di, j+dj

#### 부분집합 전부 출력

```python
for i in range(1<<N):
    for j in range(N):
        if i & (1<<j):
            print(arr[j], end=' ')
    print()
```

## 백트래킹

모든 경우를 '탐색', 이전 단계로 거슬러 올라가 다른 가능성을 찾는 것

    `모든 가능성을 찾는 건 맞지만, 가능성 없는 경우는 제외`

1 2 3 6

1 2 4 5
