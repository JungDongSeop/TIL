### 자료구조의 평균 시간 복잡도

| 자료 구조        | 접근 | 탐색 | 삽입 | 삭제 |
| ---------------- | ---- | ---- | ---- | ---- |
| 배열1            | 1    | n    | n    | n    |
| 스택             | n    | n    | 1    | 1    |
| 큐               | n    | n    | 1    | 1    |
| 이중 연결 리스트 | n    | n    | 1    | 1    |
| 해시 테이블      | 1    | 1    | 1    | 1    |
| 이진 탐색 트리   | logn | logn | logn | logn |
| AVL 트리         | logn | logn | logn | logn |
| 레드 블랙 트리   | logn | logn | logn | logn |





## 선형 자료 구조



### 연결 리스트

- 데이터를 감싼 노드를 포인터로 연결해서, 공간적인 효율성을 극대화시킨 자료 구조.

- 삽입과 삭제가 O(1), 탐색은 O(n)

- prev 포인터와 next 포인터로 앞과 뒤의 노드를 연결



### 배열

- 크기가 정해져 있고, 인접한 메모리 위치에 있는 데이터를 모아놓은 집합.

- 정적 배열을 기반으로 설명. 탐색은 O(1), 삽입 삭제는 O(n)



랜덤 접근

- 임의의 인덱스에 접근

순차적 접근

- 저장된 순서대로 검색



### 벡터

- 동적으로 할당할 수 있는 배열 (즉, python의 append 처럼 크기를 늘리는게 가능) (C++에서 사용)

- 탐색, 맨 끝 삽입 삭제는 O(1), 중간 삽입삭제는 O(n)



### 스택

- LIFO (Last In First Out)
- 재귀적인 함수, 알고리즘, 웹 브라우저 방문 기록 등에 사용
- 삽입 및 삭제는 O(1), 탐색은 O(n)



### 큐

- FIFO (First In First Out)
- 삽입 삭제는 O(1), 탐색은 O(n)





## 비선형 자료구조



### 트리

아래 특징을 가진다.

1. 부모, 자식 계층 구조를 가짐
2. 간선 v = e + 1
3. 임의의 두 노드 사이의 경로는 유일무이하게 존재



용어

- 노드의 깊이 : 루트 노드부터 현재 노드까지의 최단 거리
- 트리의 높이 : 루트 노드부터 리프 노드까지 거리 중 가장 긴 거리
- 트리의 레벨 : 깊이와 비슷한 의미
- 서브트리



종류

- 정이진 트리 : 자식 노드가 0 or 2인 트리
- 완전 이진 트리 : 왼쪽부터 채운 이진 트리
- 변질 이진 트리 : 자식 노득 하나뿐인 트리
- 포화 이진 트리 : 모든 노드가 차 있는 이진 트리
- 균형 이진 트리 : 왼쪽과 오른쪽 노드의 높이가 1 이하인 트리



### AVL 트리

자가 균형 이진 탐색 트리. 스스로 균형을 잡는 트리

이진 탐색 트리는 최악의 경우 O(n)을 가짐 => 이 경우를 배제하고 항상 균형 잡힌 트리를 만들자! => AVL 트리

어떻게? 삽입, 삭제 할 때마다 트리 일부를 회전시켜 균형을 잡음



정의

- **높이 균형 성질**(height-balance property): 트리 T의 모든 내부 노드(internal node) v에 대하여 v의 자식 노드들의 높이 차이가 최대 1이다.

- 임의의 이진 탐색 트리 T가 높이 균형 성질을 만족할 때 AVL 트리라고 한다.
- 균형도 : 왼쪽 서브트리의 최대 높이, 오른쪽 서브트리의 최대 높이의 차.
- 균형도가 2 이상인 경우, 불균형하다고 표현
- LL 문제 : 삽입-삭제로 인해 Left-Left로 서브트리가 비대해지는 문제. 
- RR 문제 : 오른쪽이 비대해지는 문제
- LR 문제 : 루트 노드부터 왼쪽 - 오른쪽 방향으로 비대해지는 문제
- RL 문제 : 





삽입

- w의 자식으로 새로운 노드를 삽입

회전

- x, y, z 세 노드를 결정 (꼬리 - 축 - 머리 순으로 연결되어 있다고 생각)
- LL 문제의 경우, 위쪽 노드를 오른쪽 자식으로, 가운데(축) 노드를 부모 노드로, 아래쪽(꼬리) 노드를 왼쪽 자식으로 회전 (유튜브에서 영상 찾아보기)



### 레드 블랙 트리

균형 이진 탐색 트리

각 노드는 빨강 or 검정 색상을 나타내는 추가 비트를 가짐, 이 색깔들은 삽입-삭제 중 트리가 균형을 유지하도록 하는 데 사용됨

`모든 리프 노드와 루트 노드는 블랙이고, 어떤 노드가 레드면 그 노드의 자식은 반드시 블랙이다. 특정 노드에서 후손 노드로 가는 경로는 동일한 수의 검정색 노드가 존재한다.(즉 양쪽에 위치한 검정색 노드의 수가 같다)` 라는 규칙을 가짐

AVL 트리보다는 덜 균형함, but 삽입 삭제 시 재배치 가능성이 AVL 트리보다 낮아, 삽입 삭제가 많은 경우 사용 (탐색이 많으면 AVL 트리)





### 힙

- 완전 이진 트리 자료구조의 일종

- 최소 힙
  - 루트 노드가 가장 작은 값을 가짐
  - 항상 부모 노드가 자식 노드보다 작음
  - heapify
    - 부모 노드로 거슬로 올라가며, 부모보다 자신이 작은 경우 값 교체
  - 삽입
    - 리프 노드에 값 추가, 이후 그 노드에서 거슬러올라가며 값 교체
  - 삭제
    - 루트 노드에 값 삭제, 마지막 리프 노드의 값을 리프 노드에 넣음, 이후 heapify



### 우선순위 큐

우선순위가 가장 높은 데이터를 가장 먼저 처리하는 자료구조

- 가치가 높은 물건부터 꺼내서 확인해야 하는 경우
- 최대힙, 최소힙을 사용해서 해결



### 해시 테이블

[노마드코더 hash table 설명](https://www.youtube.com/watch?v=HraOg7W3VAM)

- 매우 많은 데이터들을 유한한 개수의 해시 값으로 매핑한 테이블 (딕셔너리의 조회 시간복잡도가 O(1)인 것과 관련)

- 삽입, 삭제, 탐색 시 평균 O(1) 시간 복잡도
- 대부분의 프로그래밍 언어에 자체적으로 내장 (똑똑한 사람들이 hash function을 잘 만들어 놨다)



원리

- hash table에는 내부적으로 array가 존재 (`index : value` 쌍의 array)
- hash function `f`에 대해, `f(key)`를 계산하면 `value`와 연관된 `index`가 출력됨
  - 즉 `f(key) == index`, `hash_table[index] = value`
- 만약 key1, key2 가 hash function에 대해 같은 값을 출력한다면?
  - 해당 `index` 안에 `key, value` 들로 이루어진 배열을 다시 저장, 그곳에서 선형탐색
