# 2022.09.27 (화)

### 문제 풀기

분할 정복 위주로 문제를 풀었다.

## 푼 문제 목록

### swea\_5205_퀵 정렬

- 퀵 정렬을 구현하는 문제
- 주어진 수도 코드를 참고하여 풀었다. 수도코드가 없었으면 많이 힘들었을 듯 (<인지 <=인지 등등에서)

###  swea\_5207_이진탐색

- 분할 정복 알고리즘을 이용한 이진탐색으로 문제 해결
- 왼쪽을 조사했는지 아닌지를 저장한 is_left 변수로 문제를 해결

### swea\_5208_전기버스 2

- 모든 경우 순회하지만 백트래킹으로 가지를 쳐냈다.

### swea\_5209_최소생산비용

- N-Queen 문제와 동일한 방식으로

### 백준\_12865_평범한 배낭

- 전형적인 배낭 문제
- 재귀함수 + 백트래킹으로 했는데, 아무리 해도 시간초과가 났다.
- 벽을 느꼈다.
- 타뷸레이션으로 접근한다는 말을 듣고 겨우 푼 문제
- 배낭 문제는 복잡도 O(nw), 물건의 개수 n과 무게 w인 모든 경우의 표를 채우면 된다.

### 백준\_13549_숨바꼭질 3

- 다익스트라로 푸는 문제란 걸 보고 놀랐다.
- 인접 리스트로 갈 수 있는 방향과 거리를 전부 표시, 다익스트라 실행
- 다익스트라는 heapq를 사용한다는 사실을 까먹고 deque를 쓰고 있었다.
- 다른사람 풀이를 보니 K부터 시작하는 재귀함수로 깔끔하게 풀었다. 부럽다.

### 백준\_11404_플로이드

- 다익스트라로 풀 수 있을 줄 알았는데, 간선의 수가 너무 많아 시간복잡도 $O((V+E)\log(V)$에서 시간초과가 났다. (a에서 b로 가는 버스가 2개 이상인 경우가 많음)

- 플로이드-워셜 알고리즘을 쓰면 모든 노드 쌍에 대해 최단거리를 시간복잡도 $O(V^3)$으로 해결 가능. 이 문제는 노드의 수가 작으니, 플로이드-워셜 알고리즘이 유리. (다익스트라는 $O(V*(V+E)\log V))$이다.) 

- 코드를 짜긴 했는데, 아직 직관적인 이해가 안된다. 최근 머리가 좀 나빠진 기분이 든다.. 문제 푸는데 시간도 많이 들고...

- 임의의 노드 **s**에서 **e**까지 가는 데 걸리는 최단거리를 구하기 위해, **s**와 **e** 사이의 노드인 **m**에 대해 **s**에서 **m**까지 가는 데 걸리는 최단거리와 **m**에서 **e**까지 가는 데 걸리는 최단거리를 이용 (출처-나무위키)

  ```python
  d = [[INF] * (N+1) for _ in range(N+1)]			# 이후 주어진 버스 노선들(s, e, d)로 리스트 수정
  
  for m in range(1, N+1):
      for s in range(1, N+1):
          for e in range(1, N+1):
              if s == e:
                  d[s][e] = 0
              if d[s][e] > d[s][m] + d[m][e]:
                  d[s][e] = d[s][m] + d[m][e]
  ```

   m == 1일 때, 1과 직접적으로 연결된 (s, e)들에 대한 최솟값 저장
  
  m == 2일 때, 1, 2를 거쳐 연결된 (s, e)들에 대한 최솟값 저장
  
  ...


---

## 이론 부분

- 플로이드-워셜 알고리즘은 모든 노드 쌍에 대해 최단거리를 $O(V^3)$으로 해결할 수 있다.
- 이는 간선이 매우 많은 경우 다익스트라보다 훨씬 유용하다. (다익스트라는 s가 정해진 경우, 모든 e에 대한 최단거리를 $O((V+E)\log V)$ 로 해결 가능


---

## 배운 점

- 배낭 문제는 타뷸레이션으로 해결할 수 있다.


---

## 내일 할 것

- 
