# 2022.09.22 (금)

### 문제 풀기

여러 문제들을 풀었다 (이왕이면 구현 위주로)

## 푼 문제 목록

### 백준\_3190_뱀

- 70분 걸림?
- 구현 문제
- 조금 더 방법을 생각한 뒤 짜는 버릇을 들여볼까?
- 문제 조건을 엄밀히 안읽어서 시간을 좀 날림 (머리가 늘어나고, 이후 꼬리가 줄어드는 메커니즘을 헷갈림)

###  백준\_1043_거짓말

- 25분 걸림. 확실히 5분정도 생각한 뒤에 짜니까 빠른듯? 걍 운인가?
- 그래프 dfs로 진실을 아는 사람들과 연결되지 않은 사람들 목록을 만드는게 핵심
- 입력받을 때 `5 1 2 3 4 5` 같은 경우 `n, *lists = map(int, input().split())` 하면 쉽게 숫자와 리스트로 나눠받을 수 있다.

### 백준\_1238_파티

- 90분. 다익스트라를 활용하는 문제

- 처음에는 백트래킹을 활용한 dfs로 했는데, 시간초과가 났다. (마을 N(1000), 간선 M(10000), 시간복잡도는 $O(NM^2)$)

- 어쩔 수 없이.. 우선순위 힙을 활용한 다익스트라 알고리즘을 사용했다. (복잡도 $O(N(N+M)\log M))$

- 다익스트라 알고리즘

  - 큐를 사용, 큐는 우선순위 힙을 사용해 현재까지 이동거리가 가장 작은 값을 맨 앞에 오도록 작성 (최소힙)

    이 덕분에 복잡도 $O(M)$ 이 아니라 $O(\log M)$이 가능

  - 다음에 갈 점 next에 대해서, 여태까지 조사한 거리보다 더 빠른 이동이 가능하면, 조사

- 이러면 가지치기도 더 많이 되나? 

  ㅇㅇ 그냥 dfs, bfs의 백트래킹 조건은, 이미 그 점을 지난 움직임들도 저장되어 있어서, 그 점을 더 빨리 갈 수 있음에도 계속 의미없는 계산을 반복함

- 정렬하는데만 복잡도 $O(\log M)$ 이니, 우선순위 힙 대신 병합정렬로 해도 복잡도는 같음

### 백준\_1967_트리의 지름

- 1167번 푸는 도중, 이 문제를 먼저 풀라는 말을 들어서 풀어봤다.

- 트리의 지름을 쉽게 구하는 방법이 적혀있어서 따라함

- 트리의 지름 찾는 법

  1. 한 점(여기선 루트노드)을 기준으로 거리가 가장 먼 노드 X를 구함
  2. 노드 X에서 가장 거리가 먼 노드 Y를 구함

  이러면 트리의 지름을 찾을 수 있다. (귀류법으로 증명 완료. 지름의 끝 노드를 a, b라고 가정할 때, 임의의 x에서 가장 먼 노드가 a or b가 아니라 가정하면 a, b보다 긴 지름이 생겨서 모순이 생김.)

- 재귀 깊이제한 없애는 법

  ```python
  import sys
  sys.setrecursionlimit(1000000)
  ```

### 백준\_1167_트리의 지름

- 위 문제와 똑같지만 입력이 살짝 달라지고 범위가 커졌다. 루트 노드도 안가르쳐줌
- 위와 같은 방식으로 풀었다. 그런데 재귀로 해서 그런지 시간이 굉장히 오래 걸렸다. 시간 초과가 뜨면 반복문으로 해서 dfs 구현하자.

### 백준\_1504_특정한 최단 경로

- 반드시 들러야 하는 점 p1, p2에 대해 각 부분을 다익스트라로 구해 비교적 작은 값을 구하는 문제
- 마지막 조건(방문할 수 없으면 -1 출력) 부분을 안읽어서 5분? 정도 해멨다.

### 백준\_1149_RGB마을

- 처음엔 백트래킹 + 재귀함수로 모든 경우를 조사했는데, 시간초과가 났다.
- DP란 힌트를 보니, 타뷸레이션으로 풀면 된다고 생각해서 그렇게 함

### 백준\_15654_N과 M(5)

- 단순 순열 구현 문제
- 헷갈릴 문제가 아닌데 헷갈림

### 백준\_16953_A->B

- B에서부터 생각하면 쉬운 문제


---

## 이론 부분

- heap에 대한 이해, 이를 활용한 다익스트라 구현

```python
def dijkstra(start, goal):
    distance = [INF] * (N+1)        # 해당 노드까지의 거리 리스트
    heap = []                       # 우선순위 큐

    heappush(heap, (0, start))      # 튜플의 크기 비교는 앞에 값부터 비교. 이를 이용해 원소 (거리, 노드)를 힙에 추가
                                    # 우선순위 큐를 사용해야, 최소값을 구하는 복잡도가 O(log M)이 된다. 최종 복잡도는 O(M log M)
                                    # 그냥 최소값을 구하면 복잡도가 O(M), 결국 최종 복잡도는 O(M^2)
    distance[start] = 0

    # 방문한 도시가 있는 동안
    while heap:
        dist, now = heappop(heap)       # 이동 거리가 최소인 노드를 꺼냄
        if distance[now] < dist:            # 그 노드보다 효율적인 움직임이 있으면, 넘어감
            continue
            
        # 갈 수 있는 길들 heap에 추가 (자동 정렬 됨),
        for next, long in adjList[now]:
            cost = dist + long
            # 조사한 거리보다 더 빠른 이동이 가능하면
            if distance[next] > cost:
                distance[next] = cost
                heappush(heap, (cost, next))
```



---

## 배운 점

- 튜플의 크기비교는 맨 앞 요소부터 시작한다. 이를 활용해 `heappush(heap, (dist, node))`로 힙을 다익스트라에 활용할 수 있다.
- 다익스트라라 해봤자, 그냥 bfs에 더 엄밀한 백트래킹을 한 것이다..? 그냥 가지치기


---

## 내일 할 것

- 
