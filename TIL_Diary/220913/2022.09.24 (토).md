# 2022.09.24 (토)

### 문제 풀기

알고리즘 문제 풀기

## 푼 문제 목록

### 백준\_16566_카드 게임

- 이진 탐색으로 적절한 인덱스를 찾고, 분리 집합으로 찾아갈 인덱스를 구하는 문제
- 처음엔 이진 탐색으로 idx를 찾은 뒤 pop으로 뺐는데, pop(0)은 시간복잡도가 $O(n)$이라 시간초과가 났다.
- 내 나름대로 반복문으로 분리 집합을 완성했는데 시간초과가 났다. 왠지 찾아보니, 변수 하나를 잘못 적어 답은 나오는데 복잡도가 $O(n)$ 그대로였다...
- 다른 사람이 함수로 짠 코드를 보니, 깔끔해서 이해하기 쉬웠다. 알고리즘 생각이 어려웠던 문제

###  백준\_17404_RGB거리 2

- RGB거리 1에서 조건 이 추가 (1번째 집과 마지막 집도 색이 같으면 안된다.)
- 무식하게 (1번째 집에서 R을 고르는 경우, 마지막 집의 R 비용을 INF로 한 뒤 계산), 이 짓을 G와 B에도 실행

### 백준\_1753_최단경로

- 다익스트라 구현 문제

- 처음에 힌트를 안보고 BFS로 짤 뻔 했다. 분류를 생각하는 연습을 하자

- 잘 짬. 

- 아니었다.. 다익스트라에서 노드의 재방문을 제거하는 조건문을 추가하지 않았다.

  `if dist > distance[now]: continue` 추가했어야 함

### 백준\_1865_웜홀

- 음의 가중치를 갖는 그래프 문제

- 벨만-포드에서 음의 사이클을 갖는지 확인하는 코드를 사용하면 된다. 그러니 모든 시작점에 대해 고려하는 짓거리를 할 필요가 없다.

- 처음에 약간의 이득을 보려고 조건문에 `distance[s] != INF`를 넣었는데 틀렸다.

  찾아보니 이미 많은 사람들이 비슷한 이유로 틀렸던 듯? 이유는 시작 점에서 도달하지 못하는 음의 사이클은 고려하지 않기 때문. 

- 남의 코드를 보면서 생각하는건, 오래 고민한 뒤에 하자.


### 백준\_1932_정수 삼각형

- DP 문제. 타뷸레이션으로 품

### 백준\_2206_벽 부수고 이동하기

- 생각보다 어렵다. 우여곡절이 많았던 문제

- 방법 1(질문에서 봄) : 시작점, 끝점에서 각각 BFS 써서 둘이 닿으면 그 값 출력

- 방법 2(생각함) : 재귀 사용, 벽을 한번 부순 경우 재귀함수로 BFS 활용 (시간초과 날 듯)

- 방법 1로 품, 벽에 닿을 경우 그 칸의 visited에도 걸음 수를 저장하는 게 포인트

- 그런데 시간초과가 남. 늘 하듯이 q.pop(0)을 했는데 시간복잡도 O(n)이 나옴

- deque 사용법을 익힘. 직접 순환큐를 만들어도 됐겠지만, 굳이? 라는 느낌.

- 다른 사람 풀이를 보니, bfs를 `while q: ... for r, c, w in q: ...`로 하고, board에서 '3' : 벽 안부수고 방문한 길(다시 방문할 필요 x, bfs니 최소로 벽 안부수고 방문가능하단 뜻), '0' : 안간 길, '1' : 초반 벽(벽 부수고 방문), '2' : 벽 부순 뒤 방문한 길

  로 bfs 한번만 쓰고 해결. 참 똑똑하다

  https://www.acmicpc.net/source/30819840


---

## 이론 부분

- 분리집합 알고리즘 
  - 트리 구조를 사용
  - 서로 연결되지 않은 트리를 만든 뒤, 두 트리를 잇고 싶다면 부모 노드를 연결하기만 하면 된다.
  - 단순 그래프에서 노드 A(혹은 임의의 추가 간선)가 추가된 뒤 A의 연결상태를 확인하기 위해 굳이 다시 BFS를 사용하지 않아도, 임의의 노드 B와 연결된 상태인지 아닌지를 빠르게 알 수 있다.
- 벨만 포드 알고리즘
  - 모든 점에 대해서 모든 간선을 조사하기 때문에 복잡도는 다익스트라보다 크지만, 음의 간선도 고려할 수 있다.
  - 다익스트라도 조건문 `if dist > distance[now]: continue` 를 빼면 같은 효과가 있지만, 이러면 복잡도가 너무 커진다 (노드 재방문을 해서)

- pop(0)은 복잡도가 크다. 큐를 활용할 일이 있으면 deque 사용

---

## 배운 점

- 분리집합 알고리즘 만들기
- 알고리즘을 구현해 본 뒤엔, 다른 사람들이 짠 코드를 봐서 더 가독성 및 효율이 좋은 코드를 알아보자.
- 문제 풀기 전에 어떤 알고리즘 적용할지 생각해보기(무턱대고 분류 보기 x)
- deque 사용법


---

## 내일 할 것

- 

